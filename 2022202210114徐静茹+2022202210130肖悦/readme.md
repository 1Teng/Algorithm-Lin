## 问题与算法简介

### 问题描述

根据所给题目，我们要讨论的是3D-KLP问题。给出问题 3D-KLP的形式化定义：给定一个长方型容器 $C$ 和一个长方型箱子的集合 $B = {b_1,...,b_n}$，容器 $C$ 长 $H$、宽 $W$、高 $D$,每个箱子 $b_i$ 有长 $h_i$、宽 $w_i$ 和高 $d_i$，每个箱子的体积为 $v_i = h_iw_id_i$。令 0-1 标志 $ow_i,oh_i,od_i$ 分别表示是否允许箱子尺寸 $w_i,h_i,d_i$ 作为垂直方向尺寸.设 $S$ 为 $B$ 的一个子集，定义 $S$ 中所有箱子体积之和为$V_S$，即 $v_s = \sum_{b_i∈S}{v_i}$ 。问题的目标是选择 $B$ 的一个子集 $S$，使得 $V_S$ 最大，并且满足以下条件：对任何箱子 $b_i∈S$ ，在容器 $C$ 中对应有一个装填位置；所有 $S$ 中的箱子必须全部包含在 $C$ 中；$S$ 中任何两个箱子都不重叠；$S$ 中箱子 $b_i$ 的方向必须与方向标志 $ow_i,oh_i,od_i$ 相一致。定义**子集 $S$ 对应的填充率为 $V_S/WHD$**。

将容器 $C$ 底部左上角看作三维坐标系坐标原点，长、宽、高分别在x，y，z轴，如下图所示。

### 算法简介

本文中介绍的拟人启发式算法与组合启发式算法参考了[三维装箱问题的组合启发式算法](http://www.jos.org.cn/1000-9825/18/2083.pdf)。

算法的整体思路为：通常在砌墙时，人们会放置一块参考砖，以参考砖的高度作为基准，规定每个物体的高度都不能超过参考砖的高度，当物体不能放入时，则提高参考砖的高度。受此思想的启发，在三维装箱过程中，我们也可以在**水平和垂直方向上同时引入参考砖来引导装填过程**，同时可以使用**记录可放置点**的方法来查找装填位置。

### 算法流程

输入：有序箱子集合 $B = {b_1,...,b_n}$

输出：此次装箱得到的各箱子坐标与填充率

算法描述： 

1. 置初始可放置点为坐标原点，并置两条参考线为 0

2. 按顺序装填每个箱子，对于每个箱子

   检测可放置点能否放入该箱子并且该箱子不超过参考线

   1. 若不能，通过判断Lx的值来执行不同的策略

      - 若 Lx为 0 或为H，表明应该增加 L_z 的值，即增加该箱子作为垂直方向参考箱子,在增加 L_z 值的时候，为了充分利用空间，在箱子不能放入时，增加 L_z 到 D 并重新装填该箱子；

      - 否则，增加 L_x 的值，即增加该箱子作为水平方向参考箱子, 在增加 L_x 的值时，考虑所有 x=L_x，y=0 的点，同样，在箱子不能放入时，增加Lx到H并重新装填该箱子；

   2. 若箱子能找到可放置位置(包括作为参考箱子)，则把箱子放入该位置并删除该放置点，再对箱子先后进行 x,y,z 轴上往坐标减小方向的平移，平移后增加新的放置点

3. 返回装填对应的箱子坐标与填充率(即装入容器中的箱子总体积和容器体积的比率)

伪代码：   

```
算法.3D-packing(B). 
    I = {(0,0,0)}, Lz=Lx=0; 
    for i=1 to n
    	flag=false; 
    	for (x,y,z)∈I
    		若bi可以放入位置(x,y,z)并且满足 x+hi'≤Lx, z+di'≤Lz,则
    			flag=true,退出循环; 
    	若 flag=false,则
    		若Lx=0 或Lx=H,则
    			若bi可以放入位置(0,0,Lz),则
    				x=0,y=0,z=Lz,flag=true,Lz=Lz+di',Lx=hi'; 
    			否则,
    				若Lz<D,则
   		 				Lz=D,Lx=H,i=i−1; 
    		否则
    			for (x,y,z)∈I并且x=Lx,y=0 
    				若bi可以放入位置(x,y,z)并且满足z+di≤Lz,则
    					flag=true,Lx=Lx+hi',退出循环; 
    			若flag=false,则
   					Lx=H,i=i−1; 
    	若 flag=true,则
    		把bi放入位置(x,y,z),I=I/{(x,y,z)},把bi先后沿x,y,z轴坐标减小方向平移,记平移后坐标为(x′,y′,z′), I=I∪{(x'+hi',y',z'),(x',y'+wi',z'),(x',y',z'+ di'); 
```

​	其中， **$I$ 表示有序可防止点集合**，在对 $I$ 更新时应保持 $I$ 元素的有序性；标志 $flag$ 表示当前箱子是否能放入容器中。

### 模拟退火

在上述算法中，考虑到箱子序列会很大程度上影响结果，因此我们使用了模拟退火算法来引入随机因素。具体做法为，在以体积为正序的序列中，以箱子的种类作为划分，随机交换不同种类箱子的出现顺序、改变某种箱子的形态，考虑最优的序列。具体可以参考[三维装箱问题的组合启发式算法](http://www.jos.org.cn/1000-9825/18/2083.pdf)。

算法伪代码如下
```
算法.SA-3D-packing(B). 
    把B按元素体积从大到小顺序排序,交换元素的尺寸,使得对任意箱子bi满足di≥wi≥hi; 
    f = f_best = 3D-packing(B), B_best = B; 
    for i=1 to 2 
        t=S_t, L_t=L; 
        while (t>=E_t) 
        	for j=1 to L_t
        		从 B 的邻域 N(B)中随机选取一个 B′; 
        		f′ = 3D-packing(B′), d_f = f′−f; 
            	若 d_f>0, 则
        			f=f′, B=B′;
        			若 f > f_best, 则
       		 			f_best = f, B_best=B; 
        		否则
        			随机生成一个(0,1)之间的数 x; 
        			若 x < exp(10×df/t) 
        				f=f′, B=B′;
        	L_t+=d_L, t*=d_t;
```

## 代码说明

### 项目运行方法

```
python main_int.py --method brickwork_annealing --time_limit 1400
```

&emsp;method 可选为：[brickwork, random_place, ourmethod, brickwork_annealing, ourmethod_annealing]

&emsp;time_limit：表示模拟退火算法中，模拟退火的时间限制

**注意：** 

1. 当你执行代码后，结果会被自动的保存在result文件夹下，命名方式为“方法_时间限制.txt”

2. 当你运行代码后，当前的结果不会被覆盖，而会在对应文件下进行添加，因此你可能看不到运行的结果，建议保留之前的文件，清空result文件夹后再运行。

3. 如果你运行项目有困难，可以参考run.bat中的运行方式

### 整个项目的代码结构如下

```
├─dataset
|   *.csv （经过处理后的数据）
|   process.py （数据处理脚本）
|
├─result
|   *.txt （运行结果）
|
├─solve_method
|   *.py （表示每一种方法）
|
├─box.py （基类）
|
├─main_int.py （整数条件下的主函数）
|
├─main_float.py （浮点条件下的主函数）
|
├─plot.py (绘图工具)
```

### 下面对几个方法进行说明

&emsp;brickwork：参考文章http://www.jos.org.cn/1000-9825/18/2083.pdf实现；

&emsp;random_place：该策略为每次随机选择一个可放置点进行放置，主要用于与其他方法进行对比；

&emsp;ourmethod：brickwork方法中存在参考线，但我们认为参考线并无实际价值，因此直接去掉了参考线。
