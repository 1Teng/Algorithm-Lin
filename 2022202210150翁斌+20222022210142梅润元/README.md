# 静态装载

​		方法的主要思想法主要采用了层包装的方法，也就是把三维问题分解为二维问题，将车厢沿着深度（y轴）分为多个不同的层，货物箱子按照从里层到外层的顺序依次按层填充，这样之后每个层中的货物放置就能被转化为二维问题（x轴和z轴），并在二维平面上进行从下到上顺序的装载。这种方法能够适应后续动态装载任务的要求，方便后续修改为动态算法，且通过分解子问题的方法减少了装载时的计算量。车厢建模如下图

<img src="img\20230108045306.jpg" alt="image" style="zoom:100%;" />

​		当我们将三维问题转换为二维问题后，如何选择每一层的厚度就成为了影响我们算法的效率的最关键因素。如果选择的厚度太小，则可能没有箱子能够塞入这一层中，导致层内的剩余空间遭到浪费，如果选择的厚度太大，则装满一层之后的x轴与z轴之后，层内的y轴方向将会存在大量的剩余空间。在静态实现过程，我们可以通过遍历货物信息，给出对于层厚度的几个可能的启发性取值，并通过这些取值进行迭代尝试，直到获取到最优解。此外，为了缓解空间浪费，在我们的算法中，层的厚度不是固定的，我们可以初始设定较小的层厚度，并在放置货物的过程中通过动态调整来增加该层的高度。此时，由于厚度的增加，层内将会产生一个厚度等于y值增加的值的子层layer-in-layer，通过对这一子层视为一个新的层并进行装载，这样一来，过小的层厚度就不会导致x轴与z轴方向无法填充高度太大的箱子，层厚度增加之后y轴方向产生的剩余空间也得到了最大化的利用。

​		在每一层装载时，我们将选择高度与层厚度最为接近，且在二维平面上最能够填充当前层中剩余空隙最佳的装载箱子进行摆放。当一层无法装下多余货物之后，算法将在一个新的层继续放置，直到货物放置完成或车厢无法装载为止。每完成一层的装载之后，我们都会再次分析所有剩余的箱子及其方向，确定下一层的初始厚度。最后，程序将会输出每个装载箱子在车厢内的坐标地址和其在三个维度上占据的空间。总体算法流程如下：

<img src="img\image-20230108034633492.png" alt="image-20230108034633492" style="zoom:100%;" />

​		我们的静态算法对于提供的25组实验数据的装载率都在80%以上。

# 动态装载

在将静态算法改进为动态算法时，我们在算法上做出的变化主要基于三个方面：

​    首先，由于在动态算法中无法提前获取所有箱子的信息，我们无法通过考察所有的箱子计算出每一层的初始厚度，在进行每一个新的层的装载时，我们能够借助的信息只有第一个箱子的三维信息。由于我们的算法支持层厚度的动态增长以及因厚度增长产生的layer-in-layer子层的填充，即便之后到达y轴方向长度大于层厚度的箱子我们也能在二维层中进行填充，较小的层初始厚可以在后续动态增加，而较大的层厚度则会导致y轴方向上空间上的浪费。因此，我们选择每一层最初到达的箱子三维中最小的数值作为该层初始厚度。

​    其次，在进行每一层的填充时，我们无法通过遍历每一个箱子找到适合填充当前空隙的最佳的箱子，只能尝试将当前到达的箱子填充到层内的某一个缝隙之中。由于我们对于层内的包装采用从下到上（有限填充z轴最小的空隙）的方式，如果一个箱子被填充到了上层的某一缝隙中，则说明其下方已经没有可以填充这一箱子的空隙了，这保证了算法中不会出现箱子浮空的情况。 最后，由于不再需要在填充每一层之前计算层厚度并使用不同的初始层厚度进行迭代，也不再需要在填充每一个空隙时遍历所有箱子，动态算法的时间效率将会明显由于静态算法的实现，因此我们也在实现动态算法时考虑了题目的要求，将所有的长度参数转换为了浮点数。此外，由于在进行动态装载时需要维持当前层内的各项状态信息，以便在每个箱子到来的时候直接将其装载入当前层内，我们也在主体装载迭代过程的实现上进行了一些改动。

​    最后，即便允许了层厚度的动态增加以及使用了layer-in-layer子层装载机制，如果在产生子层之后新到来的箱子无法被填充入子层之中，那么我们只能选择该丢弃箱子或者舍弃子层直接将箱子装载在新的一层之中（由于使用动态算法，每个新的箱子到达时都需要在最外层迭代中感知当前装载层的相关信息，允许子层嵌套子层的行为无法通过简单的递归进行实现，反而需要在嵌套的过程中维持每一层嵌套的信息，在某一子层装载完后一层层地进行手动恢复，而且还可能出现无限递归，因此我们认为这样的做法代码复杂性以及时空复杂性都相对较高，故没有实现嵌套），而由于我们并不知道后续的箱子是否会比当前的箱子更加合适装载，我们不愿意简单舍弃当前箱子，因此，一个厚度较大却无法填入新到达箱子的layer-in-layer子层会被我们简单舍弃，并将新箱子放置在新的一层之中。这种选择就可能导致整个子层空间的浪费。

​    为了缓解这一缺陷，我们使用了模拟退火的思想，在每次层厚度增加时只以一定的概率接受增加，且每次层厚度增加后都进行了降温处理，使后续层厚度增加的接受概率进一步地降低，从而以一定概率拒绝了一个厚度过大的子层的产生。这样一来，未使用的过大子层导致的空间浪费就能以一定概率得到避免，而当箱子被填充到新的一层之后，新的一层内便能重新产生一个相对较小的子层，重新重复二维填充以及子层填充的过程。

​    我们的算法实现了高级部分的全部五个要求，对于给定的25组数据的测试填充率普遍处于50%以上。

# 运行

- binpack_static.c 为静态装载代码
- binpack_dynamic_float.c 为动态装载代码

- data文件夹包含给定的25组测试数据及对应装载输出，也包含编译好的exe可执行文件

测试数据（txt文件）格式如下：

- 第一行指定车厢的三维
- 要装载箱子（标号，三维xyz维度大小，该类箱子个数）

```
587, 233, 220
1. 91, 54, 45, 32
2. 105, 77, 72, 24
3. 79, 78, 48, 30
```

测试文件要放在可执行文件同文件夹下，运行后输入测试文件名（无需后缀，如下3_1.txt文件只需输入3_1即可），运行完成后会输出结果信息以及对应文件名的out文件包含有装载坐标信息

<img src="img\image-20230108041424708.png" alt="image-20230108041424708" style="zoom:100%;" />

<img src="img\image-20230108041544969.png" alt="image-20230108041544969" style="zoom:100%;" />

